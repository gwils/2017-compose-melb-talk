\documentclass[usenames,dvipsnames,svgnames,table,aspectratio=169,mathserif]{beamer}

\mode<presentation> {

%\usetheme{default}
\usetheme{Madrid}

\setbeamertemplate{footline} % To remove the footer line in all slides uncomment this line

\setbeamertemplate{navigation symbols}{} % To remove the navigation symbols from the bottom of all slides uncomment this line
}
\usepackage{graphicx} % Allows including images
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables
\usepackage{hyperref}
\usepackage{apacite}
\usepackage{fancyvrb}
\usepackage{color}
\usepackage{alltt}
\usepackage{listings}
\usepackage{framed}
\usepackage{courier}
\usepackage{minted}

\hypersetup{colorlinks=false}

\setbeamertemplate{bibliography entry title}{}
\setbeamertemplate{bibliography entry location}{}
\setbeamertemplate{bibliography entry note}{}
\setbeamertemplate{itemize items}[default]
\setbeamertemplate{enumerate items}[default]
\beamertemplatenavigationsymbolsempty
\setbeamertemplate{footline}{}

\newminted{haskell}{}
\newminted{java}{}

\definecolor{g}{RGB}{0,100,0}
\newcommand{\highlight}[1]{\colorbox{yellow}{#1}}
\newcommand{\nega}[1]{\colorbox{yellow}{#1}}
\newcommand{\posi}[1]{\colorbox{green}{#1}}
\newcommand{\nl}{\vspace{\baselineskip}}
\newcommand{\pnl}{\pause \nl}

%%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title[Type Class: The Ultimate Ad Hoc]{Type Class: The Ultimate Ad Hoc} % The short title appears at the bottom of every slide, the full title is only on the title page

\author{George Wilson} % Your name
\institute[] % Your institution as it will appear on the bottom of every slide, may be shorthand to save space
{
Data61/CSIRO\\ % Your institution for the title page
\medskip
\href{george.wilson@data61.csiro.au}{george.wilson@data61.csiro.au} % Your email address
}
\date{\today} % Date, can be changed to a custom date

\begin{document}


%%% Intro section


\begin{frame}
\titlepage % Print the title page as the first slide
\end{frame}


\begin{frame}

Type classes are a language feature

\begin{itemize}
\item Haskell
\item Eta
\item Purescript
\item Clean
\end{itemize}

\pause

or sometimes a design pattern

\begin{itemize}
\item Scala
\item OCaml
\end{itemize}

\end{frame}


\begin{frame}
Let's go beyond the basics of type classes
\end{frame}


%%% Polymorphism


\begin{frame}
\begin{center}
\huge{Polymorphism}
\end{center}
\end{frame}


\begin{frame}
\begin{center}
Polymorphism is good


\begin{itemize}
\item greater reuse
\item less repetition
\item fewer names need inventing
\item fewer possible implementations
\end{itemize}
\end{center}
\end{frame}


\begin{frame}
Broadly speaking there are two major forms of polymorphism:

\begin{itemize}
\item {\it parametric} polymorphism
\item {\it ad-hoc} polymorphism
\end{itemize}
\end{frame}


\begin{frame}[fragile]

\frametitle{Parametric polymorphism (sometimes called {\it generics})}

% TODO clarify or correct this slide
A value is parametrically polymorphic iff it has at least one {\it type parameter}
which can be instantiated to {\it any type}.

\nl

Parametrically polymorphic functions behave the same way no matter which type
they are instantiated to.

\pnl

\begin{haskellcode}
reverse :: [a] -> [a]
id :: a -> a
(.) :: (b -> c) -> (a -> b) -> a -> c
\end{haskellcode}

\end{frame}


\begin{frame}[fragile]
\frametitle{Ad-hoc polymorphism}

A value which is ad-hocly polymorphic can be instantiated to different types,

and may behave differently at each type

\end{frame}


\begin{frame}[fragile]

\begin{haskellcode}
(==) :: Eq a => a -> a -> Bool
\end{haskellcode}

\pnl

\begin{haskellcode}
eqBool :: Bool -> Bool -> Bool
eqBool True True   = True
eqBool False False = True
eqBool False True  = False
eqBool True False  = False
\end{haskellcode}

\pnl

\begin{haskellcode}
eqString :: String -> String -> Bool
eqString []      []     = True
eqString (_: _)  []     = False
eqString []      (_: _) = False
eqString (c:cs)  (d:ds) = eqChar c d && eqString cs ds
\end{haskellcode}

\end{frame}


\begin{frame}
\begin{center}
\huge{Interfaces}
\end{center}
\end{frame}


\begin{frame}[fragile]
\begin{javacode}
public interface Equal<A> {
  public boolean eq(A other);
}
\end{javacode}

\pause

\begin{javacode}
public class Person implements Equal<Person> {
  public int age;
  public String name;

  public boolean eq(Person other) {
    return this.age == other.age && this.name.equals(other.name);
  }
}
\end{javacode}
\end{frame}



\begin{frame}[fragile]
\begin{javacode}
import java.util.List;

public class EqualMethods {
  public static <A extends Equal<A>> boolean elementOf(A a, List<A> list) {
    for (A element : list) {
      if (a.eq(element)) return true;
    }
    return false;
  }
}
\end{javacode}

elementOf exhibits ad-hoc polymorphism

\end{frame}


\begin{frame}
\begin{center}
\huge{Type Classes}
\end{center}
\end{frame}


\begin{frame}[fragile]
\begin{haskellcode}
class Equal a where
  eq :: a -> a -> Bool
\end{haskellcode}

\pnl

\begin{haskellcode}
data Person = Person {
  age :: Int
, name :: String
}
\end{haskellcode}

\pnl

\begin{haskellcode}
instance Equal Person where
  eq p1 p2 = eq (age p1) (age p2) && eq (name p1) (name p2)
\end{haskellcode}

\end{frame}


\begin{frame}[fragile]
\begin{haskellcode}
elementOf :: Equal a => a -> [a] -> Bool
elementOf a list = any (eq a) list
\end{haskellcode}
\end{frame}


\end{document} 
