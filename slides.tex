\documentclass[usenames,dvipsnames,svgnames,table,aspectratio=169,mathserif]{beamer}

\mode<presentation> {

%\usetheme{default}
\usetheme{Madrid}

\setbeamertemplate{footline} % To remove the footer line in all slides uncomment this line

\setbeamertemplate{navigation symbols}{} % To remove the navigation symbols from the bottom of all slides uncomment this line
}
\usepackage{graphicx} % Allows including images
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables
\usepackage{hyperref}
\usepackage{apacite}
\usepackage{fancyvrb}
\usepackage{color}
\usepackage{alltt}
\usepackage{listings}
\usepackage{framed}
\usepackage{courier}
\usepackage{minted}
\usepackage{epstopdf}

\hypersetup{colorlinks=false}

\setbeamertemplate{bibliography entry title}{}
\setbeamertemplate{bibliography entry location}{}
\setbeamertemplate{bibliography entry note}{}
\setbeamertemplate{itemize items}[default]
\setbeamertemplate{enumerate items}[default]
\beamertemplatenavigationsymbolsempty
\setbeamertemplate{footline}{}

\newminted{haskell}{}
\newminted{java}{}
\newminted{scala}{}

\definecolor{g}{RGB}{0,100,0}
\newcommand{\highlight}[1]{\colorbox{yellow}{#1}}
\newcommand{\nega}[1]{\colorbox{yellow}{#1}}
\newcommand{\posi}[1]{\colorbox{green}{#1}}
\newcommand{\nl}{\vspace{\baselineskip}}
\newcommand{\pnl}{\pause \nl}

%%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title[Type Class: The Ultimate Ad Hoc]{Type Class: The Ultimate Ad Hoc} % The short title appears at the bottom of every slide, the full title is only on the title page
\titlegraphic{\includegraphics[scale=0.2]{data61.eps}}
\author{George Wilson} % Your name
\institute[] % Your institution as it will appear on the bottom of every slide, may be shorthand to save space
{
Data61/CSIRO\\ % Your institution for the title page
\medskip
\href{george.wilson@data61.csiro.au}{george.wilson@data61.csiro.au} % Your email address
}
\date{\today} % Date, can be changed to a custom date

\begin{document}


%%%%%
%%%%% Intro section
%%%%%


\begin{frame}
\titlepage % Print the title page as the first slide
\end{frame}


\begin{frame}

Type classes are a language feature

\begin{itemize}
\item Haskell
\item Eta
\item Purescript
\item Clean
\end{itemize}

\pause

or sometimes a design pattern

\begin{itemize}
\item Scala
\item OCaml
\end{itemize}

\end{frame}


%%%%%
%%%%% Polymorphism
%%%%%

\begin{frame}
\begin{center}
\huge{Polymorphism}
\end{center}
\end{frame}


\begin{frame}
A type is {\it polymorphic} iff it can be applied at multiple types.
% TODO better definition?
\end{frame}


\begin{frame}
\begin{center}
Polymorphism is good


\begin{itemize}
\item less duplication
\item more reuse
\item fewer possible implementations
\end{itemize}
\end{center}
\end{frame}


\begin{frame}
Broadly speaking there are two major forms of polymorphism:

\begin{itemize}
\item {\it parametric} polymorphism
\item {\it ad-hoc} polymorphism
\end{itemize}
\end{frame}


\begin{frame}[fragile]

%\frametitle{Parametric polymorphism (sometimes called {\it generics})}

% TODO clarify or correct this slide
A type is {\tt parametrically polymorphic} iff it has at least one {\it type parameter}
which can be instantiated to {\it any type}.

%\nl

%Parametrically polymorphic functions behave the same way no matter which type
%they are instantiated to.

%\pnl

\begin{haskellcode}
reverse :: [a] -> [a]
id :: a -> a
(.) :: (b -> c) -> (a -> b) -> (a -> c)
\end{haskellcode}

\end{frame}


\begin{frame}[fragile]
%\frametitle{Ad-hoc polymorphism}

% TODO make a joke here about "ad-hocly"
A type which is ad-hocly polymorphic can be instantiated to different types,

and may behave differently at each type

\end{frame}


%%%%%
%%%%% WHATE ARE TYPE CLASSES
%%%%%

\begin{frame}
\begin{center}
\huge{Type Classes}
\end{center}
\end{frame}


\begin{frame}[fragile]
\begin{haskellcode}
class Equal a where
  eq :: a -> a -> Bool
\end{haskellcode}

\pnl

\begin{haskellcode}
data Person = Person {
  age :: Int
, name :: String
}
\end{haskellcode}

\pnl

\begin{haskellcode}
instance Equal Person where
  eq p1 p2 = eq (age p1) (age p2) && eq (name p1) (name p2)
\end{haskellcode}

\end{frame}


\begin{frame}[fragile]
\begin{haskellcode}
elementOf :: Equal a => a -> [a] -> Bool
elementOf a list = any (eq a) list
\end{haskellcode}
\end{frame}


\begin{frame}[fragile]
Instances can be constrained

\nl

% TODO is this the right example for this?
\begin{haskellcode}
instance Equal a => Equal (Maybe a) where
  eq Nothing  Nothing  = True
  eq (Just x) (Just y) = True
  eq (Just x) Nothing  = False
  eq Nothing  (Just y) = False
\end{haskellcode}

\pnl

We can add type class instances for types we didn't write
\end{frame}


\begin{frame}

Advantages

\begin{itemize}
\item Writing an instance for your type can unlock many functions
\item Writing functions with typeclass constraints is easy
\item You can write instances for types you did not write
\item Instances can depend on other instances if necessary
\end{itemize}

\end{frame}


%%%%%
%%%%% INTERFACES SECTION
%%%%%


\begin{frame}
\begin{center}
\huge{Interfaces}
\end{center}
\end{frame}


\begin{frame}[fragile]
\begin{javacode}
interface Equal<A> {
  public boolean eq(A other);
}
\end{javacode}

\pause

\begin{javacode}
class Person implements Equal<Person> {
  public int age;
  public String name;

  public boolean eq(Person other) {
    return this.age == other.age && this.name.equals(other.name);
  }
}
\end{javacode}
\end{frame}


\begin{frame}[fragile]
\begin{javacode}
static <A extends Equal<A>> boolean elementOf(A a, List<A> list) {
  for (A element : list) {
    if (a.eq(element)) return true;
  }
  return false;
}
\end{javacode}

\end{frame}


\begin{frame}[fragile]
\begin{javacode}
class String {
  private char[] value;
  // other definitions
}
\end{javacode}
\end{frame}


\begin{frame}[fragile]
\begin{javacode}
class String implements Equal<String> {
  private char[] value;
  // other definitions
}
\end{javacode}
\end{frame}


\begin{frame}[fragile]
\begin{javacode}
class List<A> {
  // implementation details





}
\end{javacode}
\end{frame}


\begin{frame}[fragile]
\begin{javacode}
class List<A> extends Equal<List<A>> {
  // implementation details





}
\end{javacode}
\end{frame}


\begin{frame}[fragile]
\begin{javacode}
class List<A> extends Equal<List<A>> {
  // implementation details

  public boolean eq(List<A> other) {
    // implementation...

  }
}
\end{javacode}
\end{frame}


\begin{frame}[fragile]
\begin{javacode}
class List<A> extends Equal<List<A>> {
  // implementation details

  public boolean eq(List<A> other) {
    // implementation...
    // ... but how do we compare A for equality?
  }
}
\end{javacode}
\end{frame}


\begin{frame}
\begin{itemize}
\item Interface implementation can't be conditional
\item We can only implement interfaces for types we control
\end{itemize}

\nl

I argue this makes type classes more modular and more flexible
\end{frame}


%%%%%
%%%%% SCALA SECTION
%%%%%


\begin{frame}
\begin{center}
\huge{Implicits}
\end{center}
\end{frame}


\begin{frame}
\end{frame}


\end{document} 

