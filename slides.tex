\documentclass[usenames,dvipsnames,svgnames,table,aspectratio=169,mathserif]{beamer}

\mode<presentation> {

%\usetheme{default}
\usetheme{Madrid}

% TODO make background not white for BFPG

\setbeamertemplate{footline} % To remove the footer line in all slides uncomment this line

\setbeamertemplate{navigation symbols}{} % To remove the navigation symbols from the bottom of all slides uncomment this line
}
\usepackage{graphicx} % Allows including images
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables
\usepackage{hyperref}
\usepackage{apacite}
\usepackage{fancyvrb}
\usepackage{color}
\usepackage{alltt}
\usepackage{listings}
\usepackage{framed}
\usepackage{courier}
\usepackage{minted}
\usepackage{epstopdf}

\hypersetup{colorlinks=false}

\setbeamertemplate{bibliography entry title}{}
\setbeamertemplate{bibliography entry location}{}
\setbeamertemplate{bibliography entry note}{}
\setbeamertemplate{itemize items}[default]
\setbeamertemplate{enumerate items}[default]
\beamertemplatenavigationsymbolsempty
\setbeamertemplate{footline}{}

\newminted{haskell}{}
\newminted{java}{}
\newminted{scala}{}

\definecolor{g}{RGB}{0,100,0}
\newcommand{\highlight}[1]{\colorbox{yellow}{#1}}
\newcommand{\nega}[1]{\colorbox{yellow}{#1}}
\newcommand{\posi}[1]{\colorbox{green}{#1}}
\newcommand{\nl}{\vspace{\baselineskip}}
\newcommand{\pnl}{\pause \nl}

%%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title[Type Class: The Ultimate Ad Hoc]{Type Class: The Ultimate Ad Hoc} % The short title appears at the bottom of every slide, the full title is only on the title page
\titlegraphic{\includegraphics[scale=0.2]{data61.eps}}
\author{George Wilson} % Your name
\institute[] % Your institution as it will appear on the bottom of every slide, may be shorthand to save space
{
Data61/CSIRO\\ % Your institution for the title page
\medskip
\href{george.wilson@data61.csiro.au}{george.wilson@data61.csiro.au} % Your email address
}
\date{\today} % Date, can be changed to a custom date

\begin{document}


%%%%%
%%%%% Intro section
%%%%%


\begin{frame}
\titlepage % Print the title page as the first slide
\end{frame}


\begin{frame}

Type classes are a language feature

\begin{itemize}
\item Haskell
\item Purescript
\item Eta
\item Clean
\end{itemize}

or sometimes a design pattern

\begin{itemize}
\item Scala
\end{itemize}

\end{frame}


%%%%%
%%%%% Polymorphism
%%%%%

\begin{frame}
\begin{center}
\huge{Polymorphism}
\end{center}
\end{frame}


\begin{frame}

Something which is {\it polymorhpic} has many shapes

\end{frame}


\begin{frame}
\begin{center}
Polymorphism is good


\begin{itemize}
\item less duplication
\item more reuse
\item fewer possible implementations
\end{itemize}
\end{center}
\end{frame}


\begin{frame}
Broadly speaking there are two major forms of polymorphism in programming:

\begin{itemize}
\item {\it parametric} polymorphism
\item {\it ad-hoc} polymorphism
\end{itemize}
\end{frame}


\begin{frame}[fragile]

A {\tt parametrically polymorphic} type has at least one {\it type parameter}
which can be instantiated to {\it any type}.

\nl

%Parametrically polymorphic functions behave the same way no matter which type
%they are instantiated to.

%\pnl

\begin{haskellcode}
reverse :: [a] -> [a]
id :: a -> a
(.) :: (b -> c) -> (a -> b) -> (a -> c)
\end{haskellcode}

\end{frame}


\begin{frame}[fragile]

% TODO make a joke here about "ad-hocly"
A type which is ad-hocly polymorphic can be instantiated to different types,

and may behave differently at each type

\end{frame}


%%%%%
%%%%% INTERFACES SECTION
%%%%%


\begin{frame}
\begin{center}
\huge{Interfaces}
\end{center}
\end{frame}


\begin{frame}[fragile]
\begin{javacode}
interface Equal<A> {
  public boolean eq(A other);
}
\end{javacode}

\pause

\begin{javacode}
class Person implements Equal<Person> {
  public int age;
  public String name;

  public boolean eq(Person other) {
    return this.age == other.age && this.name.equals(other.name);
  }
}
\end{javacode}
\end{frame}


\begin{frame}[fragile]
\begin{javacode}
static <A extends Equal<A>> boolean elementOf(A a, List<A> list) {
  for (A element : list) {
    if (a.eq(element)) return true;
  }
  return false;
}
\end{javacode}

\pnl

\begin{javacode}
elementOf(me, functionalProgrammers);
// true
\end{javacode}
\end{frame}


\begin{frame}[fragile]
\begin{javacode}
package java.lang;

class String {
  private char[] value;
  // other definitions
}
\end{javacode}
\end{frame}


\begin{frame}[fragile]
\begin{javacode}
package java.lang;

class String implements Equal<String> {
  private char[] value;
  // other definitions
}
\end{javacode}
\end{frame}


\begin{frame}[fragile]
\begin{javacode}
class List<A> {
  // implementation details





}
\end{javacode}
\end{frame}


\begin{frame}[fragile]
\begin{javacode}
class List<A> implements Equal<List<A>> {
  // implementation details





}
\end{javacode}
\end{frame}


\begin{frame}[fragile]
\begin{javacode}
class List<A> implements Equal<List<A>> {
  // implementation details

  public boolean eq(List<A> other) {
    // implementation...

  }
}
\end{javacode}
\end{frame}


\begin{frame}[fragile]
\begin{javacode}
class List<A> implements Equal<List<A>> {
  // implementation details

  public boolean eq(List<A> other) {
    // implementation...
    // ... but how do we compare A for equality?
  }
}
\end{javacode}
\end{frame}


\begin{frame}
\begin{itemize}
\item Interface implementation can't be conditional
\item We can only implement interfaces for types we control
\end{itemize}

\end{frame}


%%%%%
%%%%% WHAT ARE TYPE CLASSES
%%%%%


\begin{frame}
\begin{center}
\huge{Type Classes}
\end{center}
\end{frame}


\begin{frame}[fragile]
\begin{haskellcode}
class Equal a where
  eq :: a -> a -> Bool
\end{haskellcode}

\pnl

\begin{haskellcode}
data Person = Person {
  age :: Int
, name :: String
}
\end{haskellcode}

\pnl

\begin{haskellcode}
instance Equal Person where
  eq p1 p2 = eq (age p1) (age p2) && eq (name p1) (name p2)
\end{haskellcode}

\end{frame}


\begin{frame}[fragile]
\begin{haskellcode}
elementOf :: Equal a => a -> [a] -> Bool
elementOf a list =
  case list of
    []    -> False
    (h:t) -> eq a h || elementOf a t
\end{haskellcode}
\end{frame}


\begin{frame}[fragile]
Instances can be constrained

\nl

%instance Equal a => Equal (Maybe a) where
%  eq Nothing  Nothing  = True
%  eq (Just x) (Just y) = True
%  eq (Just x) Nothing  = False
%  eq Nothing  (Just y) = False

\begin{haskellcode}
instance (Equal a) => Equal [a] where
  eq []     []     = True
  eq (x:xs) []     = False
  eq []     (y:ys) = False
  eq (x:xs) (y:ys) = eq x y && eq xs ys
\end{haskellcode}

\pnl

We can add type class instances for types we didn't write
\end{frame}


\begin{frame}

\begin{itemize}
\item You can write instances for types you did not write
\item Instances can depend on other instances if necessary
\end{itemize}

\end{frame}


\begin{frame}[fragile]

There are exactly two places a type class instance is allowed to exist

\nl

\begin{columns}
\begin{column}[T]{0.49\textwidth}
\begin{block}{\tt List.hs}
\begin{haskellcode}
data [a] = []
         | (a:[a])
\end{haskellcode}
\end{block}
\end{column}
\begin{column}{0.02\textwidth}
\end{column}
\begin{column}[T]{0.49\textwidth}
\begin{block}{\tt Equal.hs}
\begin{haskellcode}
class Equal a where
  eq :: a -> a -> Bool

instance Equal [a] where
  eq = ...
\end{haskellcode}
\end{block}
\end{column}
\end{columns}

\end{frame}


\begin{frame}[fragile]

There are exactly two places a type class instance is allowed to exist

\nl

\begin{columns}
\begin{column}[T]{0.49\textwidth}
\begin{block}{\tt List.hs}
\begin{haskellcode}
data [a] = []
         | (a:[a])

instance Equal [a] where
  eq = ...
\end{haskellcode}
\end{block}
\end{column}
\begin{column}{0.02\textwidth}
\end{column}
\begin{column}[T]{0.49\textwidth}
\begin{block}{\tt Equal.hs}
\begin{haskellcode}
class Equal a where
  eq :: a -> a -> Bool
\end{haskellcode}
\end{block}
\end{column}
\end{columns}

\end{frame}


\begin{frame}
%TODO
TODO show why type classes aren't perfectly flexible

(no custom local instances, maybe show newtypes for sum and product or something)
\end{frame}

%%%%%
%%%%% IMPLICITS (SCALA) SECTION
%%%%%


\begin{frame}
\begin{center}
\Huge{Implicits}

\nl

\large{{\it More Flexible Than Typeclasses}\texttrademark}
\end{center}
\end{frame}


\begin{frame}[fragile]
\begin{scalacode}
case class Person(age: Int, name: String)
\end{scalacode}

\pnl

\begin{scalacode}
trait Equal[A] {
  def eq(a: A, b: A): Boolean
}
\end{scalacode}

\pnl

\begin{scalacode}
implicit def equalPerson: Equal[Person] = new Equal[Person] {
  def eq(a: Person, b: Person): Boolean =
    a.age == b.age && a.name == b.name
}
\end{scalacode}
\end{frame}


\begin{frame}[fragile]
\begin{scalacode}
def elementOf[A](a: A, list: List[A])
                (implicit equalA: Equal[A]): Boolean = {
  list match {
    case Nil => false
    case (h::t) => equal.eq(a, h) || elementOf(a, t)
  }
}
\end{scalacode}
\end{frame}


\begin{frame}[fragile]
\begin{scalacode}
implicit def equalList(implicit equalA: Equal[A]): Equal[List[A]] =
  new Equal[List[A]] {
    def eq(a: List[A], b: List[A]): Boolean = {
      (a,b) match {
        case (Nil,   Nil)   => true
        case (x::xs, Nil)   => false
        case (Nil,   y::ys) => false
        case (x::xs, y::ys) => equalA.eq(x,y) || eq(xs,ys)
      }
    }
  }
\end{scalacode}
\end{frame}


\begin{frame}
\begin{itemize}
\item We can define implicits for types we did not write
\item We can write implicits that depend on implicits
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\begin{scalacode}
sealed trait Ordering
case object LT extends Ordering
case object EQ extends Ordering
case object GT extends Ordering


trait Order[A] {
  def compare(a: A, b: A): Ordering
}
\end{scalacode}

\pnl

\begin{scalacode}
implicit def orderPerson: Order[Person] = new Order[Person] {
  def compare(a: Person, b: Person): Ordering =
    intOrder.compare(a.age, b.age) match {
      case LT => LT
      case EQ => stringOrder.compare(a.name, b.name)
      case GT => GT
    }
}
\end{scalacode}
\end{frame}


\begin{frame}[fragile]
\begin{scalacode}
def sort[A](list: List[A])(implicit orderA: Order[A]): List[A] = {
  // quicksort goes here
}
\end{scalacode}
\end{frame}


\begin{frame}[fragile]
\begin{scalacode}
sort(
  List(
    Person(30, "Robert")
  , Person(20, "John")
  , Person(40, "Alfred")
  )
)
\end{scalacode}

\pnl

\begin{scalacode}
==>

List(
  Person(20, "John")
, Person(30, "Robert")
, Person(40, "Alfred")
)
\end{scalacode}
\end{frame}


\begin{frame}[fragile]
Then the boss says ``I want those sorted by name''.

\pnl

\begin{scalacode}
implicit def personOrderByName: Order[Person] = new Order[Person] {
  def compare(a: Person, b: Person): Ordering =
    stringOrder.compare(a.age, b.age)
}
\end{scalacode}


\end{frame}


\begin{frame}[fragile]
\begin{scalacode}
sort(
  List(
    Person(30, "Robert")
  , Person(20, "John")
  , Person(40, "Alfred")
  )
)
\end{scalacode}

\pnl

\begin{scalacode}
==>

List(
  Person(40, "Alfred")
, Person(20, "John")
, Person(30, "Robert")
)

\end{scalacode}
\end{frame}


\begin{frame}
% TODO
talk about how impossible it is to understand understand which implicit wins

\nl

show Set example about incoherence doing nasty things quietly

\nl

talk about applying discipline in scala to get coherence
\end{frame}


\end{document} 

